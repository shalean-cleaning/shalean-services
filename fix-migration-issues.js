#!/usr/bin/env node

/**
 * Fix Migration Issues Script
 * 
 * This script fixes the migration history issues and applies the necessary fixes
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('ðŸ”§ Fixing Migration Issues...\n');

// 1. First, let's check the current migration status
console.log('1. Checking migration status...');
try {
  const status = execSync('npx supabase migration list', { encoding: 'utf8' });
  console.log('Current migrations:', status);
} catch (error) {
  console.log('Error checking migrations:', error.message);
}

// 2. Create a new migration with a proper timestamp
console.log('\n2. Creating new migration...');
const timestamp = new Date().toISOString().replace(/[-:]/g, '').replace(/\..+/, '');
const migrationName = `${timestamp}_fix_api_500_errors.sql`;
const migrationPath = `supabase/migrations/${migrationName}`;

const migrationContent = `-- Migration: Fix API 500 Errors
-- Description: Add missing columns that APIs expect

-- Add missing columns to bookings table
ALTER TABLE bookings 
ADD COLUMN IF NOT EXISTS auto_assign BOOLEAN DEFAULT true,
ADD COLUMN IF NOT EXISTS address TEXT,
ADD COLUMN IF NOT EXISTS postcode TEXT,
ADD COLUMN IF NOT EXISTS bedrooms INTEGER,
ADD COLUMN IF NOT EXISTS bathrooms INTEGER;

-- Add comments for documentation
COMMENT ON COLUMN bookings.auto_assign IS 'Whether to automatically assign a cleaner or allow manual selection';
COMMENT ON COLUMN bookings.address IS 'Customer address for the cleaning service';
COMMENT ON COLUMN bookings.postcode IS 'Postal code for the service location';
COMMENT ON COLUMN bookings.bedrooms IS 'Number of bedrooms to clean';
COMMENT ON COLUMN bookings.bathrooms IS 'Number of bathrooms to clean';

-- Ensure cleaners table has the correct structure
ALTER TABLE cleaners 
ADD COLUMN IF NOT EXISTS name TEXT,
ADD COLUMN IF NOT EXISTS contact_info TEXT,
ADD COLUMN IF NOT EXISTS bio TEXT,
ADD COLUMN IF NOT EXISTS active BOOLEAN DEFAULT true;

-- Update existing cleaners if needed
UPDATE cleaners 
SET name = COALESCE(name, 'Unknown Cleaner'),
    active = COALESCE(active, true)
WHERE name IS NULL OR active IS NULL;
`;

fs.writeFileSync(migrationPath, migrationContent);
console.log(`âœ… Created migration: ${migrationName}`);

// 3. Update database types
console.log('\n3. Updating database types...');
const databaseTypesPath = 'src/lib/database.types.ts';
const updatedTypes = `// This file was auto-generated by Supabase CLI.
// Do not edit this file manually.

export type Json =
  | string
  | number
  | boolean
  | null
  | { [key: string]: Json | undefined }
  | Json[]

export type Database = {
  public: {
    Tables: {
      bookings: {
        Row: {
          id: string
          customer_id: string | null
          session_id: string | null
          cleaner_id: string | null
          area_id: string | null
          service_id: string | null
          service_slug: string | null
          region_id: string | null
          booking_date: string | null
          start_time: string | null
          end_time: string | null
          start_ts: string | null
          end_ts: string | null
          status: 'DRAFT' | 'PENDING' | 'CONFIRMED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED' | 'READY_FOR_PAYMENT'
          total_price: number | null
          notes: string | null
          special_instructions: string | null
          auto_assign: boolean | null
          address: string | null
          postcode: string | null
          bedrooms: number | null
          bathrooms: number | null
          paystack_ref: string | null
          paystack_status: string | null
          created_at: string
          updated_at: string
        }
        Insert: {
          id?: string
          customer_id?: string | null
          session_id?: string | null
          cleaner_id?: string | null
          area_id?: string | null
          service_id?: string | null
          service_slug?: string | null
          region_id?: string | null
          booking_date?: string | null
          start_time?: string | null
          end_time?: string | null
          start_ts?: string | null
          end_ts?: string | null
          status?: 'DRAFT' | 'PENDING' | 'CONFIRMED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED' | 'READY_FOR_PAYMENT'
          total_price?: number | null
          notes?: string | null
          special_instructions?: string | null
          auto_assign?: boolean | null
          address?: string | null
          postcode?: string | null
          bedrooms?: number | null
          bathrooms?: number | null
          paystack_ref?: string | null
          paystack_status?: string | null
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          customer_id?: string | null
          session_id?: string | null
          cleaner_id?: string | null
          area_id?: string | null
          service_id?: string | null
          service_slug?: string | null
          region_id?: string | null
          booking_date?: string | null
          start_time?: string | null
          end_time?: string | null
          start_ts?: string | null
          end_ts?: string | null
          status?: 'DRAFT' | 'PENDING' | 'CONFIRMED' | 'IN_PROGRESS' | 'COMPLETED' | 'CANCELLED' | 'READY_FOR_PAYMENT'
          total_price?: number | null
          notes?: string | null
          special_instructions?: string | null
          auto_assign?: boolean | null
          address?: string | null
          postcode?: string | null
          bedrooms?: number | null
          bathrooms?: number | null
          paystack_ref?: string | null
          paystack_status?: string | null
          created_at?: string
          updated_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "bookings_area_id_fkey"
            columns: ["area_id"]
            isOneToOne: false
            referencedRelation: "suburbs"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_cleaner_id_fkey"
            columns: ["cleaner_id"]
            isOneToOne: false
            referencedRelation: "cleaners"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_customer_id_fkey"
            columns: ["customer_id"]
            isOneToOne: false
            referencedRelation: "profiles"
            referencedColumns: ["id"]
          },
          {
            foreignKeyName: "bookings_service_id_fkey"
            columns: ["service_id"]
            isOneToOne: false
            referencedRelation: "services"
            referencedColumns: ["id"]
          }
        ]
      }
      cleaners: {
        Row: {
          id: string
          name: string
          contact_info: string | null
          bio: string | null
          active: boolean
          created_at: string
        }
        Insert: {
          id?: string
          name: string
          contact_info?: string | null
          bio?: string | null
          active?: boolean
          created_at?: string
        }
        Update: {
          id?: string
          name?: string
          contact_info?: string | null
          bio?: string | null
          active?: boolean
          created_at?: string
        }
        Relationships: []
      }
      profiles: {
        Row: {
          id: string
          first_name: string | null
          last_name: string | null
          email: string
          role: 'CUSTOMER' | 'CLEANER' | 'ADMIN'
          created_at: string
          updated_at: string
        }
        Insert: {
          id: string
          first_name?: string | null
          last_name?: string | null
          email: string
          role?: 'CUSTOMER' | 'CLEANER' | 'ADMIN'
          created_at?: string
          updated_at?: string
        }
        Update: {
          id?: string
          first_name?: string | null
          last_name?: string | null
          email?: string
          role?: 'CUSTOMER' | 'CLEANER' | 'ADMIN'
          created_at?: string
          updated_at?: string
        }
        Relationships: []
      }
      services: {
        Row: {
          id: string
          name: string
          slug: string
          description: string | null
          base_fee: number
          active: boolean
          created_at: string
        }
        Insert: {
          id?: string
          name: string
          slug: string
          description?: string | null
          base_fee: number
          active?: boolean
          created_at?: string
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          description?: string | null
          base_fee?: number
          active?: boolean
          created_at?: string
        }
        Relationships: []
      }
      suburbs: {
        Row: {
          id: string
          name: string
          slug: string
          postcode: string
          region_id: string
          delivery_fee: number
          price_adjustment_pct: number
          active: boolean
          created_at: string
        }
        Insert: {
          id?: string
          name: string
          slug: string
          postcode: string
          region_id: string
          delivery_fee: number
          price_adjustment_pct?: number
          active?: boolean
          created_at?: string
        }
        Update: {
          id?: string
          name?: string
          slug?: string
          postcode?: string
          region_id?: string
          delivery_fee?: number
          price_adjustment_pct?: number
          active?: boolean
          created_at?: string
        }
        Relationships: [
          {
            foreignKeyName: "suburbs_region_id_fkey"
            columns: ["region_id"]
            isOneToOne: false
            referencedRelation: "regions"
            referencedColumns: ["id"]
          }
        ]
      }
      regions: {
        Row: {
          id: string
          name: string
          state: string
          active: boolean
          created_at: string
        }
        Insert: {
          id?: string
          name: string
          state: string
          active?: boolean
          created_at?: string
        }
        Update: {
          id?: string
          name?: string
          state?: string
          active?: boolean
          created_at?: string
        }
        Relationships: []
      }
    }
    Views: {
      [_ in never]: never
    }
    Functions: {
      [_ in never]: never
    }
    Enums: {
      [_ in never]: never
    }
    CompositeTypes: {
      [_ in never]: never
    }
  }
}

type PublicSchema = Database[Extract<keyof Database, "public">]

export type Tables<
  PublicTableNameOrOptions extends
    | keyof (PublicSchema["Tables"] & PublicSchema["Views"])
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
        Database[PublicTableNameOrOptions["schema"]]["Views"])
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? (Database[PublicTableNameOrOptions["schema"]]["Tables"] &
      Database[PublicTableNameOrOptions["schema"]]["Views"])[TableName] extends {
      Row: infer R
    }
    ? R
    : never
  : PublicTableNameOrOptions extends keyof (PublicSchema["Tables"] &
        PublicSchema["Views"])
    ? (PublicSchema["Tables"] &
        PublicSchema["Views"])[PublicTableNameOrOptions] extends {
        Row: infer R
      }
      ? R
      : never
    : never

export type TablesInsert<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Insert: infer I
    }
    ? I
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Insert: infer I
      }
      ? I
      : never
    : never

export type TablesUpdate<
  PublicTableNameOrOptions extends
    | keyof PublicSchema["Tables"]
    | { schema: keyof Database },
  TableName extends PublicTableNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicTableNameOrOptions["schema"]]["Tables"]
    : never = never,
> = PublicTableNameOrOptions extends { schema: keyof Database }
  ? Database[PublicTableNameOrOptions["schema"]]["Tables"][TableName] extends {
      Update: infer U
    }
    ? U
    : never
  : PublicTableNameOrOptions extends keyof PublicSchema["Tables"]
    ? PublicSchema["Tables"][PublicTableNameOrOptions] extends {
        Update: infer U
      }
      ? U
      : never
    : never

export type Enums<
  PublicEnumNameOrOptions extends
    | keyof PublicSchema["Enums"]
    | { schema: keyof Database },
  EnumName extends PublicEnumNameOrOptions extends { schema: keyof Database }
    ? keyof Database[PublicEnumNameOrOptions["schema"]]["Enums"]
    : never = never,
> = PublicEnumNameOrOptions extends { schema: keyof Database }
  ? Database[PublicEnumNameOrOptions["schema"]]["Enums"][EnumName]
  : PublicEnumNameOrOptions extends keyof PublicSchema["Enums"]
    ? PublicSchema["Enums"][PublicEnumNameOrOptions]
    : never
`;

fs.writeFileSync(databaseTypesPath, updatedTypes);
console.log('âœ… Updated database types');

// 4. Update API code to use correct column names
console.log('\n4. Updating API code...');

// Update cleaners availability API
const cleanersApiPath = 'src/app/api/cleaners/availability/route.ts';
let cleanersApiContent = fs.readFileSync(cleanersApiPath, 'utf8');

// Fix the query to use correct column names
cleanersApiContent = cleanersApiContent.replace(
  /\.select\(`[\s\S]*?`\)/,
  `.select(\`
          id,
          name,
          contact_info,
          bio,
          active,
          created_at
        \`)`
);

// Remove the complex booking filter that's causing syntax errors
cleanersApiContent = cleanersApiContent.replace(
  /\.eq\('is_active', true\)\s*\.eq\('is_available', true\);/,
  `.eq('active', true);`
);

// Fix the cleaner name extraction
cleanersApiContent = cleanersApiContent.replace(
  /const profile = cleaner\.profiles;\s*const cleanerName = profile \? `\${profile\.first_name} \${profile\.last_name}` : 'Unknown Cleaner';/,
  `const cleanerName = cleaner.name || 'Unknown Cleaner';`
);

fs.writeFileSync(cleanersApiPath, cleanersApiContent);
console.log('âœ… Updated cleaners availability API');

// Update bookings draft API
const bookingsApiPath = 'src/app/api/bookings/draft/route.ts';
let bookingsApiContent = fs.readFileSync(bookingsApiPath, 'utf8');

// Add back the auto_assign field since we're adding it to the database
bookingsApiContent = bookingsApiContent.replace(
  /const insertData: any = \{\s*status: 'DRAFT',\s*booking_date: new Date\(\)\.toISOString\(\)\.split\('T'\)\[0\],\s*start_time: '09:00',\s*end_time: '11:00',\s*total_price: 0\s*\}/,
  `const insertData: any = {
      status: 'DRAFT',
      booking_date: new Date().toISOString().split('T')[0],
      start_time: '09:00',
      end_time: '11:00',
      total_price: 0,
      auto_assign: true
    }`
);

// Add back the auto_assign field to update logic
bookingsApiContent = bookingsApiContent.replace(
  /\/\/ auto_assign column not available in current schema/,
  `if (requestData.autoAssign !== undefined) updateData.auto_assign = requestData.autoAssign`
);

fs.writeFileSync(bookingsApiPath, bookingsApiContent);
console.log('âœ… Updated bookings draft API');

console.log('\nðŸŽ‰ All fixes applied!');
console.log('\nðŸ“‹ Next steps:');
console.log('1. Run: npx supabase db push');
console.log('2. Restart your dev server: npm run dev');
console.log('3. Test the APIs again');
console.log('\nâœ¨ The 500 errors should now be resolved!');
